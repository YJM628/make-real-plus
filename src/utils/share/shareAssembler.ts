/**
 * Share HTML Assembler
 * Feature: share-app-link
 * Requirements: 2.2, 2.3, 2.4
 *
 * Assembles processed pages into a single self-contained HTML file for sharing.
 * Unlike staticAssembler, all CSS and mock data are inlined — no external file references.
 *
 * Key differences from assembleStaticProject (staticAssembler.ts):
 * - Returns a single HTML string instead of Map<string, string>
 * - shared.css inlined as <style> tag instead of <link> reference
 * - Mock interceptor script and mock data inlined as <script> tags instead of external file references
 * - Mock data embedded as JSON variable in script
 * - Single page: simplified HTML without router script
 * - Multi page: SPA with hash-based routing, all pages as hidden divs
 */

import type { ProcessedPage, MockGenerationResult } from '../../types';
import { generateRouterScript } from '../export/routerScript';

/**
 * Assemble processed pages into a single self-contained HTML string for sharing.
 *
 * @param pages - Array of processed pages with HTML/CSS/JS content
 * @param sharedCSS - Common CSS extracted from multiple pages
 * @param pageCSS - Page-specific CSS (page name -> CSS content)
 * @param deps - Design system CDN dependencies (stylesheets and scripts)
 * @param mockResult - Mock data generation result
 * @param appName - Application name
 * @returns A single self-contained HTML string
 *
 * Requirements:
 * - 2.2: All pages assembled into single HTML; multi-page includes routing, single-page does not
 * - 2.3: All CSS inlined in <style> tags (no external css/shared.css reference)
 * - 2.4: Mock interceptor and mock data inlined in <script> tags (no external mock/ references)
 */
export function assembleShareHtml(
  pages: ProcessedPage[],
  sharedCSS: string,
  pageCSS: Map<string, string>,
  deps: { stylesheets: string[]; scripts: string[] },
  mockResult: MockGenerationResult,
  appName: string
): string {
  const isSinglePage = pages.length === 1;

  const headContent = buildShareHeadSection(
    appName,
    sharedCSS,
    deps,
    mockResult
  );

  let bodyContent: string;
  if (isSinglePage) {
    bodyContent = buildShareSinglePageBody(pages[0], pageCSS);
  } else {
    const defaultPage = pages[0].name;
    bodyContent = buildShareMultiPageBody(pages, pageCSS, defaultPage);
  }

  return `<!DOCTYPE html>
<html lang="en">
${headContent}
${bodyContent}
</html>`;
}

/**
 * Build the <head> section with all dependencies inlined.
 *
 * Requirement 2.3: CSS inlined as <style> tags
 * Requirement 2.4: Mock interceptor inlined as <script> tag
 */
function buildShareHeadSection(
  appName: string,
  sharedCSS: string,
  deps: { stylesheets: string[]; scripts: string[] },
  mockResult: MockGenerationResult
): string {
  const parts: string[] = [];

  parts.push('<head>');
  parts.push('  <meta charset="UTF-8">');
  parts.push('  <meta name="viewport" content="width=device-width, initial-scale=1.0">');
  parts.push(`  <title>${escapeHtml(appName)}</title>`);

  // Add design system CDN stylesheets (external CDN links are fine)
  for (const stylesheet of deps.stylesheets) {
    parts.push(`  <link rel="stylesheet" href="${escapeHtml(stylesheet)}">`);
  }

  // Requirement 2.3: Inline shared CSS as <style> tag (not <link> to css/shared.css)
  if (sharedCSS.trim()) {
    parts.push('  <style>');
    parts.push(indentText(sharedCSS, 4));
    parts.push('  </style>');
  }

  // Add design system CDN scripts (external CDN links are fine)
  for (const script of deps.scripts) {
    parts.push(`  <script src="${escapeHtml(script)}"></script>`);
  }

  // Requirement 2.4: Inline mock interceptor and mock data as <script> tags
  if (mockResult.mockFiles.size > 0) {
    parts.push('  <script>');
    parts.push(indentText(generateInlineMockScript(mockResult), 4));
    parts.push('  </script>');
  }

  parts.push('</head>');

  return parts.join('\n');
}

/**
 * Generate an inline mock interceptor script with embedded mock data.
 *
 * Instead of referencing external mock files, the mock data is embedded as a
 * JSON object and the interceptor reads from it directly.
 *
 * Requirement 2.4: Mock data embedded as JSON variable in script
 */
function generateInlineMockScript(mockResult: MockGenerationResult): string {
  // Build the mock data map: route key -> JSON data
  const mockDataMap: Record<string, string> = {};
  for (const endpoint of mockResult.endpoints) {
    const routeKey = `${endpoint.method}:${endpoint.path}`;
    mockDataMap[routeKey] = JSON.stringify(endpoint.mockData);
  }

  return `
/**
 * Inline Mock API Interceptor
 * Generated by share-app-link
 *
 * Mock data is embedded directly — no external file references.
 */
(function() {
  'use strict';

  // Embedded mock data: 'METHOD:path' -> JSON string
  const mockData = ${JSON.stringify(mockDataMap, null, 2)};

  // Store original fetch
  const originalFetch = window.fetch;

  // Override fetch
  window.fetch = function(url, options) {
    options = options || {};
    const method = (options.method || 'GET').toUpperCase();

    // Extract path from URL
    let path = url;
    try {
      if (url.startsWith('http://') || url.startsWith('https://')) {
        const urlObj = new URL(url);
        path = urlObj.pathname;
      } else if (!url.startsWith('/')) {
        path = '/' + url;
      }
      path = path.split('?')[0].split('#')[0];
    } catch (e) {
      // Use url as-is
    }

    const routeKey = method + ':' + path;
    const data = mockData[routeKey];

    if (data !== undefined) {
      console.log('[Mock Interceptor] Intercepting:', method, path);
      return Promise.resolve(new Response(data, {
        status: 200,
        headers: { 'Content-Type': 'application/json' }
      }));
    }

    return originalFetch(url, options);
  };

  // Also intercept XMLHttpRequest
  var OriginalXHR = window.XMLHttpRequest;
  window.XMLHttpRequest = function() {
    var xhr = new OriginalXHR();
    var originalOpen = xhr.open;
    var _method = 'GET';
    var _mockData = null;

    xhr.open = function(method, url) {
      _method = method.toUpperCase();
      var path = url;
      try {
        if (url.startsWith('http://') || url.startsWith('https://')) {
          var urlObj = new URL(url);
          path = urlObj.pathname;
        } else if (!url.startsWith('/')) {
          path = '/' + url;
        }
        path = path.split('?')[0].split('#')[0];
      } catch (e) {
        // Use url as-is
      }

      var routeKey = _method + ':' + path;
      _mockData = mockData[routeKey] || null;

      if (_mockData) {
        console.log('[Mock Interceptor] Intercepting XHR:', _method, path);
      }

      return originalOpen.apply(xhr, arguments);
    };

    return xhr;
  };

  console.log('[Mock Interceptor] Initialized with', Object.keys(mockData).length, 'routes (inline)');
})();
`.trim();
}

/**
 * Build body content for single-page share HTML.
 *
 * Simple structure: page content with inline styles and scripts, no router.
 * Requirement 2.2: Single page generates simplified structure without routing.
 */
function buildShareSinglePageBody(
  page: ProcessedPage,
  pageCSS: Map<string, string>
): string {
  const parts: string[] = [];

  parts.push('<body>');

  // Add page-specific CSS if exists
  const pageCss = pageCSS.get(page.name);
  if (pageCss && pageCss.trim()) {
    parts.push('  <style>');
    parts.push(indentText(pageCss, 4));
    parts.push('  </style>');
  }

  // Add page HTML content
  parts.push('');
  parts.push(indentText(page.html, 2));
  parts.push('');

  // Add page-specific JavaScript if exists
  if (page.js && page.js.trim()) {
    parts.push('  <script>');
    parts.push(indentText(page.js, 4));
    parts.push('  </script>');
  }

  parts.push('</body>');

  return parts.join('\n');
}

/**
 * Build body content for multi-page share HTML (SPA architecture).
 *
 * All pages embedded as hidden divs, controlled by router script.
 * Requirement 2.2: Multi-page includes hash-based routing with all pages as hidden divs.
 */
function buildShareMultiPageBody(
  pages: ProcessedPage[],
  pageCSS: Map<string, string>,
  defaultPage: string
): string {
  const parts: string[] = [];

  parts.push('<body>');

  // Add page-specific CSS for all pages
  const allPageCSS = Array.from(pageCSS.entries())
    .map(([pageName, css]) => {
      if (!css || !css.trim()) return '';
      return `    /* Page: ${pageName} */\n${indentText(css, 4)}`;
    })
    .filter(Boolean)
    .join('\n\n');

  if (allPageCSS) {
    parts.push('  <style>');
    parts.push(allPageCSS);
    parts.push('  </style>');
  }

  // Add page containers (all hidden by default, router will show the active one)
  parts.push('');
  parts.push('  <!-- Page containers -->');
  for (const page of pages) {
    const isDefault = page.name === defaultPage;
    const displayStyle = isDefault ? 'block' : 'none';

    parts.push(`  <div id="page-${escapeHtml(page.name)}" class="page-container" style="display: ${displayStyle};">`);
    parts.push(indentText(page.html, 4));
    parts.push('  </div>');
    parts.push('');
  }

  // Add page-specific JavaScript for all pages
  const hasAnyJS = pages.some(page => page.js && page.js.trim());
  if (hasAnyJS) {
    parts.push('  <script>');
    for (const page of pages) {
      if (page.js && page.js.trim()) {
        parts.push(`    // Page: ${page.name}`);
        parts.push(indentText(page.js, 4));
        parts.push('');
      }
    }
    parts.push('  </script>');
  }

  // Add router script for multi-page navigation
  const pageNames = pages.map(p => p.name);
  const routerScript = generateRouterScript(pageNames, defaultPage);
  parts.push('');
  parts.push('  <script>');
  parts.push(indentText(routerScript, 4));
  parts.push('  </script>');

  parts.push('</body>');

  return parts.join('\n');
}

/**
 * Escape HTML special characters
 */
function escapeHtml(text: string): string {
  const map: Record<string, string> = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#039;',
  };
  return text.replace(/[&<>"']/g, (char) => map[char]);
}

/**
 * Indent text by a specified number of spaces
 */
function indentText(text: string, spaces: number): string {
  const indent = ' '.repeat(spaces);
  return text
    .split('\n')
    .map(line => (line ? indent + line : line))
    .join('\n');
}
